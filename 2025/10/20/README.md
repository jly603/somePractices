估了快半个月了。

不想找借口，没做就是没做

> # P1022 [NOIP 2000 普及组] 计算器的改良
>
> ## 题目背景
>
> NCL 是一家专门从事计算器改良与升级的实验室，最近该实验室收到了某公司所委托的一个任务：需要在该公司某型号的计算器上加上解一元一次方程的功能。实验室将这个任务交给了一个刚进入的新手 ZL 先生。
>
> ## 题目描述
>
> 为了很好的完成这个任务，ZL 先生首先研究了一些一元一次方程的实例：
>
> - $4+3x=8$。
> - $6a-5+1=2-2a$。
> - $-5+12y=0$。
>
> ZL 先生被主管告之，在计算器上键入的一个一元一次方程中，只包含整数、小写字母及 `+`、`-`、`=` 这三个数学符号（当然，符号“`-`”既可作减号，也可作负号）。方程中并没有括号，也没有除号，方程中的字母表示未知数。
>
> 你可假设对键入的方程的正确性的判断是由另一个程序员在做，或者说可认为键入的一元一次方程均为合法的，且有唯一实数解。
>
> ## 输入格式
>
> 一个一元一次方程。
>
> ## 输出格式
>
> 解方程的结果（精确至小数点后三位）。
>
> ## 输入输出样例 #1
>
> ### 输入 #1
>
> ```
> 6a-5+1=2-2a
> ```
>
> ### 输出 #1
>
> ```
> a=0.750
> ```

<hr>

非常有意思的题目。。。

精确至小数点后三位，用 `printf("%.3f", result)` 表示。

？

我还是直接看题解，学习一下怎么处理这些字符串吧。。。

> 这道题思维难度和代码难度都不大，就是细节处理有点麻烦，需要判断一些特殊情况（~~比如 --0.0什么的~~）。那我就直接上~~代码~~思路了。
>
> ------
>
> 因为是一元一次方程，所以最终一定可以化成 *k**x*+*b*=0 的形式，整理可得 *x*=−*k**b* ，为了~~减少变量数~~方便，将等号右边的多项式直接移到等式左边，即系数均乘 -1，可以用一个变量标记一下。
>
> ------
>
> ## 然后就是一连串的判断：
>
> 1. 对于符号 ‘+’，‘-’，‘=’ 的处理
>
> ```cpp
> if(c=='-') {b+=now*f*x;x=0;f=-1;}
> if(c=='+') {b+=now*f*x;x=0;f=1;}
> if(c=='=') {b+=now*f*x;x=0;f=1;now=-1;}
> ```
>
> 
>
> ```cpp
> 这里 b 为常数部分的值；now 表示相对等号的位置，左边为 1 ，右边为 -1；f 表示项的系数的正负性，x 则是项的系数。
> 
> 读到加号，常数累加，系数清零，符号标记为正，减号同理。读到等号则需额外将 now 改为 -1。
> ```
>
> 
>
> 1. 关于数字的读入
>
> ```cpp
> if(c>='0'&&c<='9') {x=x*10+c-'0';}
> ```
>
> 
>
> ```cpp
> 若判定为数字则叠加当前项系数。
> ```
>
> 
>
> 1. 关于未知数的处理
>
> ```cpp
> if(c>='a'&&c<='z') {k+=now*f*x;x=0;a=c;}
> ```
>
> 
>
> ```cpp
> 若判定为小写字母，则将未知数的系数累加，项系数清零，并标记未知数名 a。   
> ```
>
> 
>
> ------
>
> 至此，这一题就成功的~~解决~~挂掉了。因为(~~变量 r 的含义还没讲呢！~~)还有
>
> ## 特殊情况
>
> 1. 要是遇到 +x , -x 这种情况怎么办？
>
>    那还不简单，系数为 0 就默认改为 1 就好了嘛。
>
>    ```cpp
>    if(c>='a'&&c<='z')
>    {
>    	x?k+=now*f*x:k+=now*f;
>        x=0;a=c;
>    }
>    ```
>
>    
>
>    那如果是 +0x , -0x 这种~~毒瘤~~情况又怎么办？
>
>    这就需要引入一个新的变量 r 来标记是否有系数的读入。至于 r 的处理，只需要在读到数字时将 r 置为 1 ，读到其它字符都将 r 置为 0 就行了。
>
>    ```cpp
>    if(c=='-') {b+=now*f*x;x=0;f=-1;r=0;}
>    if(c=='+') {b+=now*f*x;x=0;f=1;r=0;}
>    if(c=='=') {b+=now*f*x;x=0;f=1;now=-1;r=0;}
>    if(c>='a'&&c<='z')
>    {
>    	if(r)
>    	{
>    		k+=now*f*x;x=0;
>    	}
>    	else k+=now*f;
>    	a=c;r=0;
>    }
>    if(c>='0'&&c<='9') {x=x*10+c-'0';r=1;}
>    ```
>
>    
>
> 2. 遇到 −*x*=0 这种情况总是输出 -0.0 怎么办？
>
>    我就是这个原因死在了第五个点，~~看了题解才知道原来是因为~~ 0 除以负数会被计算成 -0.0 。所以需要特判一下。
>
> # 完整AC代码如下：
>
> ```cpp
> #include <iostream>
> #include <cstdio>
> using namespace std;
> char c,a;//c用来读入,a是未知数名
> int f=1,now=1,k,b,x;//f初始化为正，now初始为左，k、b、x意义如上
> bool r;//用来判是否有数字读入
> int main()
> {
> 	while(cin>>c)//各种处理上面已经解释的很清楚了……（吧）
> 	{
> 		if(c=='-') {b+=now*f*x;x=0;f=-1;r=0;}
> 		if(c=='+') {b+=now*f*x;x=0;f=1;r=0;}
> 		if(c=='=') {b+=now*f*x;x=0;f=1;now=-1;r=0;}
> 		if(c>='a'&&c<='z')
> 		{
> 			if(r)
> 			{
> 				k+=now*f*x;x=0;
> 			}
> 			else k+=now*f;
> 			a=c;r=0;
> 		}
> 		if(c>='0'&&c<='9') {x=x*10+c-'0';r=1;}
> 	}
> 	b+=now*f*x;//加上最后一项常数（若最后一项是未知数则会加0）
>     double ans=double(-b*1.0/k);
> 	if(ans==-0.0) ans=0;//特判，将-0.0改为0
> 	printf("%c=%.3lf",a,ans);//保留三位小数输出
> 	return 0;
> }
> ```

非常害怕，已严肃学习

> 1. 关于数字的读入
>
> ```cpp
> if(c >= '0' && c <= '9') {x = x * 10 + c - '0';}
> ```
>
> ```cpp
> 若判定为数字则叠加当前项系数。
> ```

卧槽，非常好数字读入，可以学。

很厉害。非常好的思路，学到了。

唉，细节处理慢慢学。

而且题解总体思路清晰，处理到位，是字符串处理的范本。

而且，很久没遇到这样会说人话的题解了（

问问AI是怎么做的

> 我们把等号左边和右边分别处理，把常数项和含未知数项的系数累加，最后解出未知数即可。
> 具体步骤：
> 1. 
> 从左到右扫描字符串，遇到  =  时，把左边和右边的处理方式交换（左边系数加，右边系数减）。
> 2. 
> 用一个变量  sign  记录当前项的符号（初始为  1 ），遇到  -  变  -1 ，遇到  +  变  1 。
> 3. 
> 用一个变量  num  记录当前数字（初始为  0 ），遇到数字就累加。
> 4. 
> 如果当前字符是字母，那么这一项是未知数项，系数为  sign * num （如果  num  为  0 ，则系数为  sign ），累加到未知数总系数中；否则这一项是常数项，累加到常数总和中。
> 5. 
> 最后解方程：未知数 = -常数总和 / 未知数总系数。

这其实还没题解处理的好，但思维也非常清晰。

看完题解我自己再试试吧。

。。。

试了一下，我甚至刚开始就错了，我刚开始的思路是输入一段字符串，但题解却是逐字扫入实时处理

逐字读入最优，而不是读入整条字符串后再分析

感觉被剧透完了，非常沮丧，都不是自己想的

```C++
while (cin >> c) {
    //代码;
}
```

逐字扫入实时处理。这倒是没回车，因为是读入文件，调试可以用

至少有收获，不是没收获。