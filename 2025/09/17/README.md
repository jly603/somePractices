今天也是。正正常常地写一个小时。

###### 昨天的因为太难了就没写。感谢大佬帮助，但是我仍然没做出来。 ~~**丢人不**~~

从今天开始就是正规的NOIP题目了。试试热身一下。

今天写两道题试试。不知道能不能写完。

话不多说 —— We begin our code day.

<hr>

> # P1012 [NOIP 1998 提高组] 拼数
>
> ## 题目描述
>
> 设有 $n$ 个正整数 $a_1 \dots a_n$，将它们联接成一排，相邻数字首尾相接，组成一个最大的整数。
>
> ## 输入格式
>
> 第一行有一个整数，表示数字个数 $n$。
>
> 第二行有 $n$ 个整数，表示给出的 $n$ 个整数 $a_i$。
>
> ## 输出格式
>
> 一个正整数，表示最大的整数
>
> ## 输入输出样例 #1
>
> ### 输入 #1
>
> ```
> 3
> 13 312 343
> ```
>
> ### 输出 #1
>
> ```
> 34331213
> ```
>
> ## 输入输出样例 #2
>
> ### 输入 #2
>
> ```
> 4
> 7 13 4 246
> ```
>
> ### 输出 #2
>
> ```
> 7424613
> ```
>
> ## 说明/提示
>
> 对于全部的测试点，保证 $1 \leq n \leq 20$，$1 \leq a_i \leq 10^9$。
>
> NOIP1998 提高组 第二题

<hr>

如题。该题为1998年的提高组第二题，是一道 `普及/提高-` ,目前没有读题，不知含金量。

第一反应是如果要组成一个最大的整数的话，应该选最高位数最大的数字放在前面。

现在的第一思路：用递归来做，首先先比较每个数的最高位（不是 `0` ，范围为 `1-9` ），排除最大值以外的所有数字。剩下的数字比较次高一位（范围为 `0-9` ），重复上述操作......直到最大值以外的所有数字个数为0为止。此时选取第一个数直接输出，并将该数从数组中删除（清 `0` ），就可以避免两个数重复的情况（例如 `3` 个数： 13 343 343 ）。然后 `step+1` ，继续上述步骤，直到 `step == n` 为止，输出最后一个数，结束。

我可能需要一个函数 `organize(num)` ，将我输入的数字进行位数拆分，然后由高到低存进数组 `array[21][10]` 。（ `10` 为 `位数最大值+1` ）因此，我可能需要将该二维数组的值均初始化为 `-1` ，避免无法处理最低位为 `0` 的情况。这个应该算是全局变量吧......又到了我最喜欢的设变量环节。到底有多少个变量在里头啊，囸。

然后还有一个问题就是要怎么拆分。拆分的话可以把一个数字不断 `%10` 、 `/10` ，直到该数字为 `0` 为止。但是我是从最高位开始拆分的啊？我要由高到低把位数放进去来着，我想后进先出，那怎么办？用栈吗，我还不会写栈。算了，那这里就史一点，应该能过。

这道题好像细节确实比较多。我可能已经踩到某个坑里了。也有可能就不该这么想。但是已经骑虎难下了，只能这么想了（）

已经脑袋混乱了，做不过来了。不是想不出来，而是细节太多了，太内耗了，现在有点堵住了。要不是前面写下这么多文字，我已经忘了自己在做什么了。可能得再坚持一下。

今天一直在忙别的，先把这份给传了，cpp有一直在写，我写完会上传到GitHub。没时间。

大佬上一题的代码也有一直在抄。当时没想到会这么难，我只想了个搜索。现在搜索熟练一点可能也算好处。最后看大佬教也看懂了，（我这么垃圾的脑子欸！）所以真的说的很通俗易懂。

明天继续。时间线有点混乱，确实没时间。但是可能每天都做点也好。9.18
