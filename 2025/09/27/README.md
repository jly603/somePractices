不知道。感觉怪怪的

做一道比较经典的。

<hr>

> # P1057 [NOIP 2008 普及组] 传球游戏
>
> ## 题目描述
>
> 上体育课的时候，小蛮的老师经常带着同学们一起做游戏。这次，老师带着同学们一起做传球游戏。
>
> 游戏规则是这样的：$n$ 个同学站成一个圆圈，其中的一个同学手里拿着一个球，当老师吹哨子时开始传球，每个同学可以把球传给自己左右的两个同学中的一个（左右任意），当老师再次吹哨子时，传球停止，此时，拿着球没有传出去的那个同学就是败者，要给大家表演一个节目。
>
> 聪明的小蛮提出一个有趣的问题：有多少种不同的传球方法可以使得从小蛮手里开始传的球，传了 $m$ 次以后，又回到小蛮手里。两种传球方法被视作不同的方法，当且仅当这两种方法中，接到球的同学按接球顺序组成的序列是不同的。比如有三个同学 $1$ 号、$2$ 号、$3$ 号，并假设小蛮为 $1$ 号，球传了 $3$ 次回到小蛮手里的方式有 $1 \rightarrow 2 \rightarrow 3 \rightarrow 1$ 和 $1 \rightarrow 3 \rightarrow 2 \rightarrow 1$，共 $2$ 种。
>
> ## 输入格式
>
> 一行，有两个用空格隔开的整数 $n,m(3 \le n \le 30,1 \le m \le 30)$。
>
> ## 输出格式
>
> $1$ 个整数，表示符合题意的方法数。
>
> ## 输入输出样例 #1
>
> ### 输入 #1
>
> ```
> 3 3
> ```
>
> ### 输出 #1
>
> ```
> 2
> ```
>
> ## 说明/提示
>
> ### 数据范围及约定
>
> - 对于 $40\%$ 的数据，满足：$3 \le n \le 30,1 \le m \le 20$；
> - 对于 $100\%$ 的数据，满足：$3 \le n \le 30,1 \le m \le 30$。
>
> 2008普及组第三题

<hr>

感觉像一道比较简单的递归。这道题应该主要还是靠思维，代码应该还蛮简单的。

（或者我想多了？这就是一道简单的搜索？不可能吧，感觉用搜索会超时）

要搜2的30次方次，大概就是10^9...不可能。

所以。。。试着做了以下简化（我也不知道我是怎么想象出来的）：

![https://github.com/jly603/somePractices/blob/master/2025/09/27/20250927_01.png]()



题目的意思相当于把向上走当作向左传，向右走当作向右传，那么表中的每个点都包含3个信息：

`num` ：该点的号数（总数就是 `n` ）；

`step` ：走到该点所需要的步数（也就是 `m` ）；

`path` ：走到该点一共所能经过的路径（也就是方法数）。

提前打表，把这个 `30*30` 的三维结构体打出来，然后按需应求

（找到 `num` 为 `1` 、 `step` 为 `m` 的点，然后 `sum += path` ）即可。

```C++
#include<iostream>
#define ll long long
using namespace std;
int m, n;
ll sum = 0;
struct node {
	int num;
	int step;
	ll path;
}sheet[31][31];
int main() {
	cin >> n >> m;
	//打表(num)
	for (int i = 1; i <= 30; i++) {
		int j = i % n, k = 1;
		while (k <= 30) {
			if (!j) j = n;
			sheet[i][k].num = j;
			k++; j--;
		}
	}
	//打表(step)
	for (int i = 1; i <= 30; i++) {
		for (int j = 1; j <= 30; j++) {
			sheet[i][j].step = i + j - 2;
		}
	}
	//打表(path)
	for (int i = 1; i <= 30; i++) {
		for (int j = 1; j <= 30; j++) {
			if (i == 1 || j == 1)
				sheet[i][j].path = 1;
			else {
				sheet[i][j].path = sheet[i - 1][j].path + sheet[i][j - 1].path;
			}
		}
	}
	for (int i = 1; i <= 30; i++) {
		for (int j = 1; j <= 30; j++) {
			if (sheet[i][j].num == 1 && sheet[i][j].step == m)
				sum += sheet[i][j].path;
		}
	}
	cout << sum;
	return 0;
}
```

但是为什么只有70分。。。





