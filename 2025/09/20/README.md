现在是凌晨了。

https://github.com/jly603/somePractices/blob/master/2025/09/17/README.md

这题我的思路一开始就是错的。没有考虑到这种情况：

54和543最大是54543，34和345最大是34534。

这怎么写啊。看题解了。

> ## Solution
>
> ### 策略来源：
>
> 首先简化问题，根据观察，我们可以很容易发现，如果都是一位数字进行组合，那肯定是越大的数字在越前面得到的数字最大。
>
> ### 简单思考：
>
> 我们可以想到如果两个数字进行组合，由于组合后的单个数字总个数不变，所以仍然遵循前面的原则，这时我们可以想到将两种拼接后的数字的字典序进行比较（因为字典序是根据 ASCLL 码一位一位从前往后比较的）。由此我们便可以得出的两个数字的拼接最优解。
>
> ### 思考推广：
>
> 如果是多个数字，那我们可以先化繁为简，即如果我们通过字典序得到了 *a*+*b* 大于 *b*+*a*，*b*+*c* 大于 *c*+*b*（这里 + 是拼接符号），则根据字典序的大小比较一定可以得到 *a*+*c* 大于 *c*+*a*（可以通过分类讨论或将数字通过循环使数字位数相同进行推导），可以推得 *a*+*b*+*c* 一定大于其他所有情况（因为如果不是这种情况则一定可以通过交换相邻的数字来使得这两位组成的数字更大，使得拼接后的整个数字更大），由此我们可以推导出，无论处理多少个数字，只需要保证在排序后前一个数字和后一个数字拼接后的字典序大于（或等于）反向拼接的字典序即可。

我写了一个多小时，原来有现成的。

操。

而且这样就解决了上述的情况。

很烦。还是不能第一时间想到用STL解决问题。需要多积累。

话说STL是什么时候引入的啊 看一下

> “此后，随者 C++ 标准的不断改进，STL 也在不断地做着相应的演化。直至 ***1998*** 年，ANSI/ISO C++ 标准正式定案，STL 始终是 C++ 标准库不可或缺的重要组成部分。”

操。

<hr>

今天继续打。

<hr>

> # P1970 [NOIP 2013 提高组] 花匠
>
> ## 题目背景
>
> NOIP2013 提高组 D2T2
>
> ## 题目描述
>
> 花匠栋栋种了一排花，每株花都有自己的高度。花儿越长越大，也越来越挤。栋栋决定把这排中的一部分花移走，将剩下的留在原地，使得剩下的花能有空间长大，同时，栋栋希望剩下的花排列得比较别致。
>
> 具体而言，栋栋的花的高度可以看成一列整数 $h_1,h_2,\ldots,h_n$。设当一部分花被移走后，剩下的花的高度依次为 $g_1,g_2,\ldots,g_m$，则栋栋希望下面两个条件中至少有一个满足：
>
> 条件 A：对于所有的 $1 \le i \le \frac{m}{2}$，有 $g_{2 i} > g_{2 i - 1}$，同时对于所有的 $1 \le i \le \frac{m}{2}$，有 $g_{2 i} > g_{2 i + 1}$；  
> 条件 B：对于所有的 $1 \le i \le \frac{m}{2}$，有 $g_{2 i} < g_{2 i - 1}$，同时对于所有的 $1 \le i \le \frac{m}{2}$，有 $g_{2 i} < g_{2 i + 1}$。
>
> 注意上面两个条件在 $m = 1$ 时同时满足，当 $m > 1 $ 时最多有一个能满足。
>
> 请问，栋栋最多能将多少株花留在原地。
>
> ## 输入格式
>
> 第一行包含一个整数 $n$，表示开始时花的株数。
>
> 第二行包含 $n$ 个整数，依次为 $h_1,h_2,\ldots,h_n$，表示每株花的高度。
>
> ## 输出格式
>
> 输出一行，包含一个整数，表示最多能留在原地的花的株数。
>
> ## 输入输出样例 #1
>
> ### 输入 #1
>
> ```
> 5
> 5 3 2 1 2
> ```
>
> ### 输出 #1
>
> ```
> 3
> ```
>
> ## 说明/提示
>
> **输入输出样例说明**
>
> 有多种方法可以正好保留 $3$ 株花，例如，留下第 $1$、$4$、$5$ 株，高度分别为 $5$、$1$、$2$，满足条件 B。
>
> **数据范围**
>
> 对于 $20\%$的数据，$n \le 10$；
>
> 对于 $30\%$的数据，$n \le 25$；
>
> 对于 $70\%$的数据，$n \le 1000$，$0 \le h_i \le 1000$；
>
> 对于 $100\%$的数据，$1 \le n \le {10}^5$，$0 \le h_i \le {10}^6$，所有的 $h_i$ 随机生成，所有随机数服从某区间内的均匀分布。

<hr>

偶数的花要比两边奇数的花高，大概是这个意思

不对。应该是不能出现连续三朵花梯状排列的情况。

然后就懵逼了。

灵光乍现，找转折点。把所有的花当成柱状图，再绘制成折线图，然后找曲线的极值点数量，然后+2（头尾），就是答案了。

~~草那好像很好写，是不是做完了~~

# **记得去重复。**

```C++
#include<iostream>
using namespace std;
#define ll long long
int main() {
	ll n, num = -1, sum = 0;
	ll back = -1, front = -1;
	ll p;
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> p;
		if (p != front) {
			back = num;
			num = front;
			front = p;
			if (back != -1 && (back - num) * (front - num) > 0)
				sum++;
		}
	}
	if (n == 1) cout << 1;
	else if (n == 2) {
		if (front == num) cout << 1;
		else cout << 2;
	}
	else if (sum + 2 > n) cout << n;
	else cout << sum + 2;
	return 0;
}
```

过过过

















