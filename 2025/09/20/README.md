现在是凌晨了。

https://github.com/jly603/somePractices/blob/master/2025/09/17/README.md

这题我的思路一开始就是错的。没有考虑到这种情况：

54和543最大是54543，34和345最大是34534。

这怎么写啊。看题解了。

> ## Solution
>
> ### 策略来源：
>
> 首先简化问题，根据观察，我们可以很容易发现，如果都是一位数字进行组合，那肯定是越大的数字在越前面得到的数字最大。
>
> ### 简单思考：
>
> 我们可以想到如果两个数字进行组合，由于组合后的单个数字总个数不变，所以仍然遵循前面的原则，这时我们可以想到将两种拼接后的数字的字典序进行比较（因为字典序是根据 ASCLL 码一位一位从前往后比较的）。由此我们便可以得出的两个数字的拼接最优解。
>
> ### 思考推广：
>
> 如果是多个数字，那我们可以先化繁为简，即如果我们通过字典序得到了 *a*+*b* 大于 *b*+*a*，*b*+*c* 大于 *c*+*b*（这里 + 是拼接符号），则根据字典序的大小比较一定可以得到 *a*+*c* 大于 *c*+*a*（可以通过分类讨论或将数字通过循环使数字位数相同进行推导），可以推得 *a*+*b*+*c* 一定大于其他所有情况（因为如果不是这种情况则一定可以通过交换相邻的数字来使得这两位组成的数字更大，使得拼接后的整个数字更大），由此我们可以推导出，无论处理多少个数字，只需要保证在排序后前一个数字和后一个数字拼接后的字典序大于（或等于）反向拼接的字典序即可。

我写了一个多小时，原来有现成的。

操。

而且这样就解决了上述的情况。

很烦。还是不能第一时间想到用STL解决问题。需要多积累。

话说STL是什么时候引入的啊 看一下

> “此后，随者 C++ 标准的不断改进，STL 也在不断地做着相应的演化。直至 ***1998*** 年，ANSI/ISO C++ 标准正式定案，STL 始终是 C++ 标准库不可或缺的重要组成部分。”

操。

<hr>

今天继续打。

<hr>

> # P1970 [NOIP 2013 提高组] 花匠
>
> ## 题目背景
>
> NOIP2013 提高组 D2T2
>
> ## 题目描述
>
> 花匠栋栋种了一排花，每株花都有自己的高度。花儿越长越大，也越来越挤。栋栋决定把这排中的一部分花移走，将剩下的留在原地，使得剩下的花能有空间长大，同时，栋栋希望剩下的花排列得比较别致。
>
> 具体而言，栋栋的花的高度可以看成一列整数 $h_1,h_2,\ldots,h_n$。设当一部分花被移走后，剩下的花的高度依次为 $g_1,g_2,\ldots,g_m$，则栋栋希望下面两个条件中至少有一个满足：
>
> 条件 A：对于所有的 $1 \le i \le \frac{m}{2}$，有 $g_{2 i} > g_{2 i - 1}$，同时对于所有的 $1 \le i \le \frac{m}{2}$，有 $g_{2 i} > g_{2 i + 1}$；  
> 条件 B：对于所有的 $1 \le i \le \frac{m}{2}$，有 $g_{2 i} < g_{2 i - 1}$，同时对于所有的 $1 \le i \le \frac{m}{2}$，有 $g_{2 i} < g_{2 i + 1}$。
>
> 注意上面两个条件在 $m = 1$ 时同时满足，当 $m > 1 $ 时最多有一个能满足。
>
> 请问，栋栋最多能将多少株花留在原地。
>
> ## 输入格式
>
> 第一行包含一个整数 $n$，表示开始时花的株数。
>
> 第二行包含 $n$ 个整数，依次为 $h_1,h_2,\ldots,h_n$，表示每株花的高度。
>
> ## 输出格式
>
> 输出一行，包含一个整数，表示最多能留在原地的花的株数。
>
> ## 输入输出样例 #1
>
> ### 输入 #1
>
> ```
> 5
> 5 3 2 1 2
> ```
>
> ### 输出 #1
>
> ```
> 3
> ```
>
> ## 说明/提示
>
> **输入输出样例说明**
>
> 有多种方法可以正好保留 $3$ 株花，例如，留下第 $1$、$4$、$5$ 株，高度分别为 $5$、$1$、$2$，满足条件 B。
>
> **数据范围**
>
> 对于 $20\%$的数据，$n \le 10$；
>
> 对于 $30\%$的数据，$n \le 25$；
>
> 对于 $70\%$的数据，$n \le 1000$，$0 \le h_i \le 1000$；
>
> 对于 $100\%$的数据，$1 \le n \le {10}^5$，$0 \le h_i \le {10}^6$，所有的 $h_i$ 随机生成，所有随机数服从某区间内的均匀分布。

<hr>

偶数的花要比两边奇数的花高，大概是这个意思

不对。应该是不能出现连续三朵花梯状排列的情况。

然后就懵逼了。

灵光乍现，找转折点。把所有的花当成柱状图，再绘制成折线图，然后找曲线的极值点数量，然后+2（头尾），就是答案了。

~~草那好像很好写，是不是做完了~~

# **记得去重复。**

```C++
#include<iostream>
using namespace std;
#define ll long long
int main() {
	ll n, num = -1, sum = 0;
	ll back = -1, front = -1;
	ll p;
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> p;
		if (p != front) {
			back = num;
			num = front;
			front = p;
			if (back != -1 && (back - num) * (front - num) > 0)
				sum++;
		}
	}
	if (n == 1) cout << 1;
	else if (n == 2) {
		if (front == num) cout << 1;
		else cout << 2;
	}
	else if (sum + 2 > n) cout << n;
	else cout << sum + 2;
	return 0;
}
```

过过过，下一题



<hr>

> # P7960 [NOIP2021] 报数
>
> ## 题目描述
>
> 报数游戏是一个广为流传的休闲小游戏。参加游戏的每个人要按一定顺序轮流报数，但如果下一个报的数是 $7$ 的倍数，或十进制表示中含有数字 $7$，就必须跳过这个数，否则就输掉了游戏。
>
> 在一个风和日丽的下午，刚刚结束 SPC20nn 比赛的小 r 和小 z 闲得无聊玩起了这个报数游戏。但在只有两个人玩的情况下计算起来还是比较容易的，因此他们玩了很久也没分出胜负。此时小 z 灵光一闪，决定把这个游戏加强：任何一个十进制中含有数字 $7$ 的数，它的所有倍数都不能报出来！
>
> 形式化地，设 $p(x)$ 表示 $x$ 的十进制表示中是否含有数字 $7$，若含有则 $p(x) = 1$，否则 $p(x) = 0$。则一个正整数 $x$ 不能被报出，当且仅当存在正整数 $y$ 和 $z$ ，使得 $x = yz$ 且 $p(y) = 1$。
>
>
> 例如，如果小 r 报出了 $6$ ，由于 $7$ 不能报，所以小 z 下一个需要报 $8$；如果小 r 报出了 $33$，则由于 $34 = 17 \times 2$，$35 = 7 \times 5$ 都不能报，小 z 下一个需要报出 $36$ ；如果小 r 报出了 $69$，由于 $70 \sim 79$ 的数都含有 $7$，小 z 下一个需要报出 $80$ 才行。
>
> 现在小 r 的上一个数报出了 $x$，小 z 想快速算出他下一个数要报多少，不过他很快就发现这个游戏可比原版的游戏难算多了，于是他需要你的帮助。当然，如果小 r 报出的 x 本身是不能报出的，你也要快速反应过来小 r 输了才行。
>
> 由于小 r 和小 z 玩了很长时间游戏，你也需要回答小 z 的很多个问题。
>
> ## 输入格式
>
> 第一行，一个正整数 $T$ 表示小 z 询问的数量。
>
> 接下来 $T$ 行，每行一个正整数 $x$，表示这一次小 r 报出的数。
>
> ## 输出格式
>
> 输出共 $T$ 行，每行一个整数，如果小 r 这一次报出的数是不能报出的，输出 $-1$，否则输出小 z 下一次报出的数是多少。
>
> ## 输入输出样例 #1
>
> ### 输入 #1
>
> ```
> 4
> 6
> 33
> 69
> 300
> ```
>
> ### 输出 #1
>
> ```
> 8
> 36
> 80
> -1
> ```
>
> ## 输入输出样例 #2
>
> ### 输入 #2
>
> ```
> 5
> 90
> 99
> 106
> 114
> 169
> ```
>
> ### 输出 #2
>
> ```
> 92
> 100
> 109
> -1
> 180
> ```
>
> ## 输入输出样例 #3
>
> ### 输入 #3
>
> ```
> 见附件中的 number/number3.in
> ```
>
> ### 输出 #3
>
> ```
> 见附件中的 number/number3.ans
> ```
>
> ## 输入输出样例 #4
>
> ### 输入 #4
>
> ```
> 见附件中的 number/number4.in
> ```
>
> ### 输出 #4
>
> ```
> 见附件中的 number/number4.ans
> ```
>
> ## 说明/提示
>
> **【样例解释 #1】**
>
> 这一组样例的前 $3$ 次询问在题目描述中已有解释。
>
> 对于第 $4$ 次询问，由于 $300 = 75 \times 4$，而 $75$ 中含有 $7$ ，所以小 r 直接输掉了游戏。
>
> **【数据范围】**
>
> 对于 $10\%$ 的数据，$T \leq 10$，$x \leq 100$。  
> 对于 $30\%$ 的数据，$T \leq 100$，$x \leq 1000$。  
> 对于 $50\%$ 的数据，$T \leq 1000$，$x \leq 10000$。  
> 对于 $70\%$ 的数据，$T \leq 10000$，$x \leq 2 \times {10}^5$。  
> 对于 $100\%$ 的数据，$1 \le T \leq 2 \times {10}^5$，$1 \le x \leq {10}^7$。

<hr>

应该是先想办法打表（ `$1 \le x \leq {10}^7$` ）。然后打完直接按表走。

打表的时候要跳过已经标记的部分。没剪枝的话时间会超。

但是这个打表很很很很很烦。我感觉它有什么巧夺天工的方法。

我要不然直接看题解吧。

> 这道题提前预处理单纯地筛一筛就可以了，没有别的任何操作。
>
> 需要注意的是，在预处理时要合理的剪枝，保证时间复杂度控制在 *O*(107+*T*)（107 是数据范围，*T*是询问数）。
>
> 我们用 *f* 数组表示该数是否被标记。如果一个数 *i* 被标记过了，就直接跳过；如果 *i* 含有数字 7，我们就将 *i* 的所有倍数（包括 *i* 本身）全部标记。
>
> 我们用 *n**x* 数组（也就是 *n**e**x**t* 的缩写）来记录该数的下一个报的数是多少。在处理的时候，我们需要记录上一个报的数 *l**s*（*l**a**s**t* 的缩写，也就是没有标记的数）。如果 *i* 没有标记过也不含有数字 7，那么 *n**x**l**s* 就是 *i*，然后将 *l**s* 更新为 *i*。
>
> 预处理的好处就是保证询问的时候每次询问都是 *O*(1)。如果询问的 *x* 被标记了，就输出 −1；反之，输出 *n**x**x*。
>
> 还要注意一点，考场上一定要用上读入优化和输出优化，小心可能会被卡。
>
> 代码非常的好写，看看就可以了：
>
> ```cpp
> #include <bits/stdc++.h>
> using namespace std;
> inline int read()//读入优化
> {
>     int x = 0, f = 1;
>     char ch = getchar();
>     while (!isdigit(ch))
>     {
>         f = ch != '-';
>         ch = getchar();
>     }
>     while (isdigit(ch))
>     {
>         x = (x << 1) + (x << 3) + (ch ^ 48);
>         ch = getchar();
>     }
>     return f ? x : -x;
> }
> inline void write(int x)//输出优化
> {
>     if (x >= 10)
>         write(x / 10);
>     putchar(x % 10 + 48);
> }
> const int N = 1e7 + 100;
> int T, x, ls;
> int f[N], nx[N];
> bool check(int x)//判断是否含有数字7
> {
>     while (x)
>     {
>         if (x % 10 == 7)
>             return 1;
>         x /= 10;
>     }
>     return 0;
> }
> void init()//预处理部分
> {
>     for (int i = 1; i <= N - 10; i++)
>     {
>         if (f[i])//如果被标记过，就跳过
>             continue;
>         if (check(i))//如果含有数字7，标记其倍数
>         {
>             for (int j = i; j <= N - 10; j += i)
>                 f[j] = 1;
>             continue;
>         }
>         nx[ls] = i;//记录i
>         ls = i;//更新ls
>     }
> }
> int main()
> {
>     init();//先预处理
>     T = read();
>     while (T--)
>     {
>         x = read();
>         if (f[x])//被标记了输出-1，否则输出nx
>             puts("-1");
>         else
>             write(nx[x]), putchar('\n');
>     }
>     return 0;
> }
> ```

没有巧夺天工，没有新的东西。跟我想的差不多。

我都不知道我看完题解学到了什么。

这题出得像给鱼去腥一样恶心烦人。纯粹**经验与熟练度**。

就跟打块用速度压人一样。

还好我没写。我都不熟练我写个屁。

多抄几遍吧。没办法，偷懒肯定是不行的，这是势必要经历的。









