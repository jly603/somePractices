今天再做一道题。

<hr>

> # P1025 [NOIP 2001 提高组] 数的划分
>
> ## 题目描述
>
> 将整数 $n$ 分成 $k$ 份，且每份不能为空，任意两个方案不相同（不考虑顺序）。
>
> 例如：$n=7$，$k=3$，下面三种分法被认为是相同的。
>
> $1,1,5$;   
> $1,5,1$;   
> $5,1,1$.
>
> 问有多少种不同的分法。
>
> ## 输入格式
>
> $n,k$ （$6<n \le 200$，$2  \le k  \le  6$）
>
> ## 输出格式
>
> $1$ 个整数，即不同的分法。
>
> ## 输入输出样例 #1
>
> ### 输入 #1
>
> ```
> 7 3
> ```
>
> ### 输出 #1
>
> ```
> 4
> ```
>
> ## 说明/提示
>
> 四种分法为：  
> $1,1,5$;  
> $1,2,4$;  
> $1,3,3$;  
> $2,2,3$.
>
> **【题目来源】**
>
> NOIP 2001 提高组第二题

<hr>

好像有点摸不明白。

这道题应该是用递归去做，且后出现的数只会比前出现的数大。

具体分为两个变量：

`num` ：到这一步最小是什么数字。

`step` ：一个分了几个数字（到k为止）。

草。甚至不用减脂。

```c++
#include<iostream>
using namespace std;
int n, k, sum = 0;
int number[10];
int saveData[7][201][201]; //remainNum, remainSum, num
void printNum() {
	for (int i = k; i > 0; i--)
		cout << number[i] << " ";
	cout << endl;
}
void merge(int remainNum, int remainSum, int num) {
	if (saveData[remainNum][remainSum][num])
		sum += saveData[remainNum][remainSum][num];
	else {
		number[remainNum] = num;
		if (remainNum == 1) {
			if (remainSum == num) {
				sum++;
				//printNum();
			}
			number[remainNum] = 0;
			return;
		}
		else {
			remainSum -= num;
			while (remainSum / (remainNum - 1) >= num) {
				merge(remainNum - 1, remainSum, num);
				num++;
			}
		}
		number[remainNum] = 0;
	}
}
int main() {
	cin >> n >> k;
	for (int i = 1; i <= n / k; i++)
		merge(k, n, i);
	cout << sum << endl;
	return 0;
}
```

要减脂就似了，用的是 `void` 写的递归。







<hr>

大概是这样的，我打算再做一道题，因为今天的时间貌似比较富余。但是疑似低估了这道题的难度了，我只看到它的通过率还蛮高的。

> # P1969 [NOIP 2013 提高组] 积木大赛
>
> ## 题目背景
>
> NOIP2013 提高组 D2T1
>
> ## 题目描述
>
> 春春幼儿园举办了一年一度的“积木大赛”。今年比赛的内容是搭建一座宽度为 $n$ 的大厦，大厦可以看成由 $n$ 块宽度为 $1$ 的积木组成，第 $i$ 块积木的最终高度需要是 $h_i$。
>
> 在搭建开始之前，没有任何积木（可以看成 $n$ 块高度为 $0$ 的积木）。接下来每次操作，小朋友们可以选择一段连续区间 $[l, r]$，然后将第 $L$ 块到第 $R$ 块之间（含第 $L$ 块和第 $R$ 块）所有积木的高度分别增加 $1$。
>
> 小 M 是个聪明的小朋友，她很快想出了建造大厦的最佳策略，使得建造所需的操作次数最少。但她不是一个勤于动手的孩子，所以想请你帮忙实现这个策略，并求出最少的操作次数。
>
> ## 输入格式
>
> 包含两行，第一行包含一个整数 $n$，表示大厦的宽度。
>
> 第二行包含 $n$ 个整数，第 $i$ 个整数为 $h_i$。
>
> ## 输出格式
>
> 建造所需的最少操作数。
>
> ## 输入输出样例 #1
>
> ### 输入 #1
>
> ```
> 5
> 2 3 4 1 2
> ```
>
> ### 输出 #1
>
> ```
> 5
> ```
>
> ## 说明/提示
>
> **样例解释**
>
> 其中一种可行的最佳方案，依次选择：$[1,5]$，$ [1,3]$，$[2,3]$，$[3,3]$，$ [5,5]$。
>
> **数据范围**
>
> - 对于 $30\%$ 的数据，有 $1 \leq n \leq 10$；
> - 对于 $70\%$ 的数据，有 $1 \leq n \leq 1000$；
> - 对于 $100\%$ 的数据，有 $1 \leq n \leq 100000$，$0 \leq h_i \leq 10000$。

<hr>

这题。最暴力的做法就是搞一个bool数组，然后真的去“搭”。那就是模拟题了（

非常遗憾并不是这样做的。这样虽然空间不会超，但是时间会超（

感觉可能还是找折线。我画一下图输入1的例子：



