今天做的题目是一道很“有意思”的模拟。

<hr>

> # P1058 [NOIP 2008 普及组] 立体图
>
> ## 题目描述
>
> 小渊是个聪明的孩子，他经常会给周围的小朋友们讲些自己认为有趣的内容。最近，他准备给小朋友们讲解立体图，请你帮他画出立体图。
>
> 小渊有一块面积为 $m \times n$ 的矩形区域，上面有 $m \times n$ 个边长为 $1$ 的格子，每个格子上堆了一些同样大小的积木（积木的长宽高都是 $1$），小渊想请你打印出这些格子的立体图。我们定义每个积木为如下格式，并且不会做任何翻转旋转，只会严格以这一种形式摆放：
>
> $$
> \def\arraystretch{1e-10}
> \begin{aligned}
> &\verb!  +---+!\\
> &\verb! /   /|!\\
> &\verb!+---+ |!\quad\textsf{高}\\
> &\verb!|   | +!\\
> &\verb!|   |/ !\quad\textsf{宽}\\
> &\verb!+---+  !\\
> & \quad\textsf{长}
> \end{aligned}$$
> 
> 
> 每个顶点用 $1$ 个加号 `+` 表示，长用 $3$ 个 `-` 表示，宽用 $1$ 个 `/`，高用两个 `|` 表示。字符 `+`，`-`，`/`，`|` 的 ASCII 码分别为 $43$，$45$，$47$，$124$。字符 `.`（ASCII 码 $46$）需要作为背景输出，即立体图里的空白部分需要用 `.` 来代替。立体图的画法如下面的规则：
> 
> 若两块积木左右相邻，图示为：
> 
> $$
> \def\arraystretch{1e-10}
> \begin{aligned}
> \verb!..+---+---+!\\
> \verb!./   /   /|!\\
> \verb!+---+---+ |!\\
> \verb!|   |   | +!\\
> \verb!|   |   |/.!\\
> \verb!+---+---+..!\\
> \end{aligned}
> $$
> 若两块积木上下相邻，图示为：
> 
> $$
> \def\arraystretch{1e-10}
> \begin{aligned}
> \verb!..+---+!\\
> \verb!./   /|!\\
> \verb!+---+ |!\\
> \verb!|   | +!\\
> \verb!|   |/|!\\
> \verb!+---+ |!\\
> \verb!|   | +!\\
> \verb!|   |/.!\\
> \verb!+---+..!\\
> \end{aligned}
> $$
> 若两块积木前后相邻，图示为：
> $$
> \def\arraystretch{1e-10}
> \begin{aligned}
> \verb!....+---+!\\
> \verb!.../   /|!\\
> \verb!..+---+ |!\\
> \verb!./   /| +!\\
> \verb!+---+ |/.!\\
> \verb!|   | +..!\\
> \verb!|   |/...!\\
> \verb!+---+....!\\
> \end{aligned}
> $$
>
> 立体图中，定义位于第 $(m,1)$ 的格子（即第 $m$ 行第 $1$ 列的格子）上面自底向上的第一块积木（即最下面的一块积木）的左下角顶点为整张图最左下角的点。
>
> ## 输入格式
>
> 第一行有用空格隔开的 $2$ 个整数 $m$ 和 $n$，表示有 $m \times n$ 个格子 $(1 \le m,n \le 50)$。
>
> 接下来的 $m$ 行，是一个 $m \times n$ 的矩阵，每行有 $n$ 个用空格隔开的整数，其中第 $i$ 行第 $j$ 列上的整数表示第 $i$ 行第 $j$ 列的格子上摞有多少个积木（$1 \le $ 每个格子上的积木数 $ \le 100$）。
>
> ## 输出格式
>
> 输出包含题目要求的立体图，是一个 $K$ 行 $L$ 列的字符串矩阵，其中 $K$ 和 $L$ 表示最少需要 $K$ 行 $L$ 列才能按规定输出立体图。
>
> ## 输入输出样例 #1
>
> ### 输入 #1
>
> ```
> 3 4
> 2 2 1 2
> 2 2 1 1
> 3 2 1 2
> ```
>
> ### 输出 #1
>
> ```
> ......+---+---+...+---+
> ..+---+  /   /|../   /|
> ./   /|-+---+ |.+---+ |
> +---+ |/   /| +-|   | +
> |   | +---+ |/+---+ |/|
> |   |/   /| +/   /|-+ |
> +---+---+ |/+---+ |/| +
> |   |   | +-|   | + |/.
> |   |   |/  |   |/| +..
> +---+---+---+---+ |/...
> |   |   |   |   | +....
> |   |   |   |   |/.....
> +---+---+---+---+......
> ```
>
> ## 说明/提示
>
> NOIP2008 普及组第四题

<hr>

大概思路应该就是表格画图。先把没画的地方全部用 `.` 填满，然后写一个放方块函数 `setBlock(x, y, z)` （以左下角为基准点），然后弄清楚大概怎么放方块就行。要按顺序放，不然会重上去。

为什么说重上去，因为看上去是一个3D的problem，但本质上可以用平面的solution（

```C++
const int MAX = 10001;
char desktop[MAX][MAX];
int angle[][] = {
    {0, 0}, {0, -3}, {4, 0}, {4, -3}, {2, -5}, {6, -5}, {6, -2}
};
int length[][] = {
    {1, 0}, {1, -3}, {3, -5}
};
int height[][] = {
    {0, -1}, {0, -2}, {4, -1}, {4, -2}, {6, -3}, {6, -4}
};
int weight[][] = {
    {5, -1}, {5, -4}, {1, -4}
};
int blank[][] = {
    {0, 0}, {2, -2}
};
void init() {
    for (int i = 0; i < MAX; i++) {
        for (int j = 0; j < MAX; j++) {
            desktop[i][j] = '.';
		}
    }
}
int setBlock(int x, int y) { //我很好奇这里怎样能写的不臭
    //留白
    for (int i = 0; i < 2; i++) {
        
	}
}
```

......已经码了一个半小时了。非常麻烦。麻烦到爆炸了，尤其是怎么截取图形的截图这一块

但AC了。

已经玩起来了

搭个j8

```
3 5
0 2 0 2 0
2 3 6 3 2
0 2 0 2 0
..........+---+........
........./   /|........
........+---+ |........
........|   | +........
........|   |/|........
........+---+ |........
........|   | +........
........|   |/|........
........+---+ |........
......+-|   | +---+....
...../  |   |/   /|-+..
....+---+---+---+ |/|..
..+-|   |   |   | +---+
./  |   |   |   |/   /|
+---+---+---+---+---+ |
|  /   /|  /   /|   | +
| +---+ | +---+ |   |/|
+-|   | +-|   | +---+ |
| |   |/| |   |/|   | +
| +---+ | +---+ |   |/.
+-|   | +-|   | +---+..
..|   |/..|   |/.......
..+---+...+---+........
```

代码如下：

<hr>

```cpp
#include<iostream>
#define wxn using
#define suki namespace
#define zxw std
wxn suki zxw;
const int MAX = 10001;
char desktop[MAX][MAX]; //前为y，后为x
int LEFT = 10000, RIGHT = 0;
int UP = 10000, DOWN = 0;
int angle[][2] = {
    {0, 0}, {0, -3}, {4, 0}, {4, -3}, {2, -5}, {6, -5}, {6, -2}
};
int length[][2] = {
    {1, 0}, {1, -3}, {3, -5}
};
int height[][2] = {
    {0, -1}, {0, -2}, {4, -1}, {4, -2}, {6, -3}, {6, -4}
};
int width[][2] = {
    {5, -1}, {5, -4}, {1, -4}
};
int blank[][2] = {
    {0, 0}, {2, -2}
};
void init() {
    for (int i = 0; i < MAX; i++) {
        for (int j = 0; j < MAX; j++) {
            desktop[i][j] = '.';
        }
    }
}
void setBlock(int y, int x) { //我很好奇这里怎样能写的不臭
    //记录
    if (y > DOWN) DOWN = y;
    if (x > RIGHT) RIGHT = x;
    if (y < UP) UP = y;
    if (x < LEFT) LEFT = x;
    //留白
    for (int i = 0; i < 2; i++) {
        for (int j = 0; j <= 3; j++) {
            for (int k = 0; k <= 4; k++) {
                desktop[y + blank[i][1] - j][x + blank[i][0] + k] = ' ';
            }
        }
    }
    //放块
    for (int i = 0; i < 7; i++) {
        desktop[y + angle[i][1]][x + angle[i][0]] = '+';
    }
    for (int i = 0; i < 3; i++) {
        desktop[y + width[i][1]][x + width[i][0]] = '/';
    }
    for (int i = 0; i < 6; i++) {
        desktop[y + height[i][1]][x + height[i][0]] = '|';
    }
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j <= 2; j++) {
            desktop[y + length[i][1]][x + length[i][0] + j] = '-';
        }
    }
}
int main() {
    init();
    int l, w, max = 0;
    int xDef = 500, yDef = 8000; //随便取的值
    int blocks[51][51];
    cin >> w >> l;
    for (int i = 0; i < w; i++) {
        for (int j = 0; j < l; j++) {
            cin >> blocks[i][j];
            if (!i && blocks[i][j] > max) {
                max = blocks[i][j];
            }
        }
    }
    for (int i = 0; i < w; i++) {
        for (int j = 0; j < l; j++) {
            for (int k = 0; k < blocks[i][j]; k++)
                setBlock(yDef + 2 * i - 3 * k, xDef + 4 * j - 2 * i);
        }
    }
    RIGHT += 6; UP -= 5;
    for (int i = UP; i <= DOWN; i++) {
    	for (int j = LEFT; j <=RIGHT; j++)
	    printf("%c", desktop[i][j]);
	    printf("\n");
	}
    return 0;
}
```

